* TODO Later
** TODO Documentation
*** TODO [#A] Go through the whole thing and make it more CLHS-like (only partially done)
    The entire basic API for Sheeple should be correctly documented.
*** TODO [#C] Put together html and pdf versions of user-guide.org
** TODO Messages/Replies
*** TODO [#A] Write unit tests for messages and replies
    This really goes hand-in-hand with the heading below, but I'm refraining
    from deleting this heading just because of how important it is.
*** TODO [#B] Standard Reply Combination
    The Standard Method Combination of CLOS is the one
    with :around, :after, :before, and "primary" replies.  It would be good to
    get Sheeple's standard reply combination to behave in the same way as this.
**** DONE Remove CALL-NEXT-REPLY from :before and :after replies
**** DONE Enable nesting of :around replies
**** TODO Ensure proper order of replies:
     Most specific :around
      ...
       Least specific :around
        Most specific :before
        ...                      ; Return values ignored
        Least specific :before
        Most specific "primary"
         ...                     ; Return values go to :around
          Least specific "primary"
        Least specific :after
        ...                      ; Return values ignored
        Most specific :after

*** TODO [#B] Clean up sources
    These files are all pretty messy, and might have some low hacks that could
    be re-hacked in a more elegant way.
**** TODO messages.lisp
**** TODO reply-definition.lisp
**** TODO reply-dispatch.lisp
*** TODO [#C] Flexible Reply Combinations
***** TODO CLOS Built-In Method Combinations
      Each of these method combinations accepts 2 types of methods: "primary"
      methods and :around methods.  The :around methods are called like the
      standard combination.  "Primary" methods are qualified with the name of
      the combination, and are called in most-specific-first order.  Their
      return values are collected and passed to the function named in the method
      combination.
****** TODO PROGN, OR, AND
       Control structure combinations. Note that the OR and AND combinations are
       not short-circuiting like the macros of the same name -- they could more
       appropriately (and maybe should, in Sheeple's version) be called EVERY
       and SOME combinations.
****** TODO LIST, APPEND, NCONC
       Collection combinations. Useful for messages that need to build up
       data. I can imagine these also being useful for extending the behavior of
       some accessors.
****** TODO MAX, MIN, +
       Computation combinations. I'd say that these are least important, because
       they can be easily fudged using the LIST combination -- just wrap with
       an :around reply, all specializers on =T=, and #'APPLY the right function.
***** TODO DEFINE-REPLY-COMBINATION
      Under CLOS, it's possible to define a completely customized method
      combination.  Even though this is not frequently used, Sheeple should
      provide a similar feature.
** TODO Dynamicity
*** TODO [#A] Better error handling
    I should go over the entirety of sheeple and start filling the thing with
    restarts.  If this is going to be usably dynamic, it needs to have proper
    reporting of crummy conditions, and a nice way of recovering from them.
*** TODO [#B] Inconsistent lambda lists
    Adlai pointed out how CLOS offers a restart when lambda-lists are inconsistent,
    offering to remove inconsistent methods.  It's useful for interactively working.
    Could I support something like this in sheeple?
*** TODO [#C] Dynamic message and reply handling
   Under CLOS, it's possible to dynamically mess with replies.  Sheeple is
   currently not as flexible in this regard.  Basically, we should provide for
   messagen and replies all the stuff in AMOP for generic functions and methods.
** TODO Integration
*** TODO With Lisp
    The backtraces are awful. Good god.
*** TODO With SLIME
    It would be nice if SLIME had better support for highlighting and indentation
    of Sheeple forms, and if it had facilities for inspecting sheeple objects.
    Being able to do M-. and stuff would also be a HUGE plus.
** TODO Other features
*** TODO Property MOP
**** TODO Local Property Creation
     Let the user control what happens when a property is created locally
     through #'(setf property-value). This could be done with the same
     *-using-metaobject interface that we've used for the MOP code this far.
**** TODO Accessor Creation
     Let the user control how accessors are created for properties. A possible
     use of such a MOP feature could be a wrapper for mapping properties, such
     as the "channel-local" properties used in Sykobot, where accessors would
     take an additional argument used as a key in the mapping.
** TODO Optimization
*** TODO Speed up accessors
   Accessors need to be fast. Really fast. Find ways to cheat that won't break everything.
*** TODO Speed up instantiation
    Since sheep are sheep now, we have to be fanatical "tree pruners" when it
    comes to optimizing any further. If we find that std-sheep are still too
    kludgy, find some way to reduce that kludge!
*** TODO Consider caching scheme for property access
    I should've done this in the first place. A simpler version of the same
    system used to dispatch replies would do wonders for read performance,
    without seriously harming writer performance.
* TODO 3.1
** TODO Metasheep Protocol
*** TODO Property MOP
*** TODO Object-creation MOP
*** TODO Begin work on message/reply MOP (maybe)
* TODO 3.0.3
** TODO Condition format strings should use pprint directives
   See, for example, the format strings of no-next-reply and
   no-applicable-replies, taken from SBCL.
** TODO "Test all the fucking time."
   This is very important. Watch the entire thing, twice.
   http://rubyhoedown2008.confreaks.com/05-bryan-liles-lightning-talk-tatft-test-all-the-f-in-time.html
   Then watch this:
   http://www.vimeo.com/1534976?pg=embed&sec=1534976
   Then go write some tests, and test all the fucking time.
*** TODO Make sure all files have mostly-complete tests
**** TODO utils.lisp
**** TODO objects.lisp
**** TODO properties.lisp
**** TODO lambda-lists.lisp
**** TODO messages.lisp
**** TODO reply-definition.lisp
***** TODO Detailed reply-(un)definition unit tests
**** TODO reply-dispatch.lisp
***** TODO Detailed dispatch unit tests
**** TODO bootstrap.lisp
**** TODO post-boot.lisp
**** DONE builtins.lisp
*** DONE Improve test for WITH-SHEEP-HIERARCHY
*** DONE Convert tests to use WITH-SHEEP-HIERARCHY
** TODO Clean up and speed up raw dispatch code
** TODO Optimize
*** TODO Property access
    Tests should be written by now, so let's start taking measures to optimize property access.
*** TODO Object creation
    Creating objects could be faster, and it would be nice to make it cons (a lot) less.
*** TODO Message dispatch
    The biggest gain in general will be from just the caching, but it would be nice to have a
    cleaner, faster raw algorithm. The caching itself can get filled up with declarations, too.

* TODO 3.0.2
** TODO Figure out exactly how DEFPROTO options are canonized
   Ideally this should be user-extensible or something.
   Also, if we don't have any options that accept multiple arguments
   (like CLOS's default-initargs) then we should consider making
   options be a plist rather than a list of lists; ie:

     (defproto foo (bar)
         (a b c)
       :nickname foo-object
       :metaobject my-metaobject)

** DONE Fix lambda-lists again
   The following should work:

   (defmessage foo (bar &key))
   (defreply foo (bar &rest all-stuff) ... )

   Whenever &key is present, &aok should be appended to the end of the method function's ll.
   Conversely, if &key is not present but &rest is, &aok should NOT be appended.
** DONE Write unit tests that confirm lambda-list congruence is correct
   The damn thing won't boot if this doesn't work. Good Enoughâ„¢
** DONE Document everything in doc/sheeple.texinfo
   Only some details of message/reply documentation are left. This is good enough for now.
** DONE Fix bug with defmessage's :reply option
* DONE 3.0.1
** DONE Compile-time crap
   Something is going on. There seem to be some compile-time side-effects we don't want that are
   causing weird conflicts. For example, bootstrap.lisp requires some special juggling involving
   eval-when in order to function, and I don't understand why. I don't really see what's going on,
   whether it can be fixed, and/or whether it should even BE fixed.
** DONE Clean up INIT trio
* DONE 3.0
  This is a rough sketch of The Road to Sheeple 3.0
** DONE Update README
** DONE Parent/Hierarchy API
*** DONE (setf object-parents)
    Needs to deal correctly with bogus parent lists
*** DONE compute-hierarchy
    Isolates the hierarchy algorithm, making it easier to write
*** DONE validate-hierarchy-list
    Do we even need this? It was in the TODO before... I guess now
    it'd just be a handler-case around the above.
** DONE API
   Go over the whole API, clean stuff up, make it more Serious.
   Mainly, the object creation API could use a little cleanup.
*** DONE Object creation
**** DONE SPAWN/MAKE-OBJECT
     SPAWN is dead. MAKE-OBJECT has changed. Is OBJECT an acceptable replacement? (I think so)
**** DONE DEFOBJECT
     Is this a good name? Perhaps DEFOBJECT (and DEFPROTO) should accept unspecialized
     property definitions that initialize properties to NIL.
**** DONE DEFPROTO
     Good name? Good API? Again, perhaps properties could be initialized to NIL by default.
*** DONE Go over the whole API again.
** DONE Implement maps
   Maps, in Self-speak, are sort of backend-classes used to represent the basic format
   of a bunch of similar objects. Implementing these would mean a huge boost in performance
   and a large reduction in memory usage, since all the "sheep-children" stuff could be held
   by the backend-class implementation. Furthermore, it would remove the dependency on
   trivial-garbage, and allow sheeple to run on lisps without user-accessible weak pointers.
   Everything will just be awesome. Also, I'll get ponies. -- sykopomp
** DONE Properties
*** DONE Reimplement properties
*** DONE TATFT
*** DONE Improve the whole add-property interface.
** DONE Messages
*** DONE Check for correctness of lambda-list congruence
    As per CLHS 7.6.4
**** DONE num-required
     Each lambda list must have the same number of required parameters.
**** DONE num-optional
     Each lambda list must have the same number of optional parameters. Each reply
     can supply its own default for an optional parameter.
**** DONE key/restp
     If any lambda list mentions &rest or &key, each lambda-list must mention one
     or both of them.
**** DONE &key and &aok
     If the message lambda list mentions &key, each reply must accept all of the keyword
     names mentioned after &key, either by accepting them explicitly, by specifying &aok,
     or by specifying &rest but not &key. Each reply can accept additional keyword arguments
     of its own. The checking of the validity of keyword names is done in the message, not
     in each reply. A reply is invoked as if the keyword argument pair whose name is
     :allow-other-keys and whose value is true were supplied, though no such argument pair
     will be passed.
**** DONE &aok consistency
     The use of &allow-other-keys need not be consistent across lambda lists. If
     &allow-other-keys is mentioned in the lambda list of any applicable reply or of
     the message, any keyword arguments may be mentioned in the call to the message.
**** DONE &aux
     The use of &aux need not be consistent across replies.

*** DONE Cache message dispatch
*** DONE Add :reply option to defmessage.
** DONE Replies
*** DONE Clean up dispatch code
    Don't try to optimize yet. Just try and reorganize the algorithm into something more
    reasonable. This'll make it easier to optimize dispatch later on.
** DONE DOCUMENTATION
   Fix the fucking documentation bullshit -- something is probably not ANSI-compatible,
   although I haven't looked at it too deeply. Either way, CLISP complains when
   documentation is enabled.
** DONE Package
   Check that all the necessary symbols are exported by the SHEEPLE package, get rid of
   deprecated stuff, etc. This should actually get inspected thoroughly before tagging.
   UPDATE: I've updated the list of symbols. It should be thoroughly double-checked
   before tagging 3.0, anyways. I may have missed some symbols. -- sykopomp
* DONE 2.2
** DONE [#A] Fix #'(setf property-value) Bug
   When a call to #'(setf property-value) requires a new direct property object
   to be allocated, it doesn't get initialized properly.
   Sample code that invokes this bug:
   CL-USER> (defproto =foo= ()
              ((var "foobar")))
      #<Sheep AKA: =FOO= #x30004145841D>
   CL-USER> (defproto =bar= (=foo=)
              ())
      #<Sheep AKA: =BAR= #x30004146B76D>
   CL-USER> (setf (var =bar=) "barfoo")
      "barfoo"
** DONE Property Metaobject
*** DONE Implement property-spec-based dispatch for property-related stuff.
    PROPERTY-VALUE should call a message that dispatches based on the metaobject
    of the property being looked up. Important for PSheep!
*** TODO Write full unit tests to make sure it all works as expected.
** DONE Make defproto behave like 1.0's defsheep.
** DONE Start writing unit-tests for Message/reply stuff
* DONE 2.1
** DONE Replace find-proto with proto
   Let's try and shorten this and see if it helps.
** DONE Keep a close eye on #@ -- do I really need it?
   Reader macros are nasty. Maybe I should've thought more before tossing it in there.
   #@ is gone.
** DONE More helpful errors
   Try and catch errors a little earlier, report more useful stuff. Is there a way
   for reply-dispatch errors to be more informative?
   Update: I think this is better?...
* DONE 2.0
  Sheeple gets serious -- and more useful. The version jumps because this will completely
  break backwards compatibility with all previous sheeple code.
** DONE New interface
*** DONE CLONE -> function
    CLONE should be turned into a very simple function: (clone &rest sheep)
*** DONE CLONE* -> DEFCLONE
    What is currently CLONE should be renamed to DEFCLONE. More involved cloning capabilities
    are still nice.
*** DONE DEFSHEEP->DEFPROTO
    Time to get a bit more serious. DEFPROTO is a much clearer name.
*** DONE Mitosis->copy-sheep
    Also, get it working properly.
*** DONE defbuzzword -> defmessage
    Rename this thing. It really doesn't have to be silly.
*** DONE defmessage -> defreply
    I think I could get used to this naming scheme instead.
*** DONE Fleeced Wolf -> Boxed built-in
*** DONE =white-fang= -> boxed-object
*** DONE Fleecing -> Autoboxing
** DONE Make psheep easier to implement
*** DONE The order in which a sheep is built needs to be planned out more carefully.
    UPDATE: I think this is just about ready. Should probably think about this for a while first,
    and then it'll be done.
    UPDATE: I think this is good enough. It's straightforward.
** DONE More cleanup and convenience
*** DONE Get rid of add-on-write. Require add-property.
    Add-on-write seems like a quick interface, but it's a bit obnoxious to deal with.
    Not only does it create a risk for some serious hard-to-track bugs, but it makes
    it trickier to allocate space for properties when using the MOP.
*** DONE Shallow-copy/deep-copy should not be options.
    These are stupid, and they clutter up the interface. Never used them, never had to.
    Deep-copy could be its own function, under a different name, but it's easy enough
    to implement externally -- I'll see if it's ever used by anyone.
*** DONE Completely remove cloneforms
*** DONE Make nicknames generic properties?
    Or something similar. Would be nice to have some pointer as to what type an object is.
    UPDATE: Not for this version. This can be done later.
*** DONE Put prototypes into their own namespace
    CL is a lisp-n. Classes, functions, variables, are all stored in different namespaces.
    Thus, even though there isn't much of a difference between regular objects and prototypes,
    prototypes defined with defproto should be dumped into their own namespace, and the =foo=
    naming scheme should be dropped as a convention.
    Implementing this is simply a matter of having a hash-table of symbol->object mappings
    (the same way find-class works). The Sheeple counterpart of find-class would be find-proto.
    UPDATE: This is mostly done. Just gotta make sure everything works properly.
*** DONE Fix reinitialize-sheep
    This should be modeled more after reinitialize-instance. i.e. it should be specified
    that its function is to update the parents and direct property values of its sheep argument.
    UPDATE: A better definition is "resets the sheep's parents with a list of new parents, and
    wipes out all its direct properties from the map."
*** DONE Implement something like Io's slotSummary
    This is really important! :-o
    UPDATE: direct-property-summary and property-summary should do the trick for now :)
    UPDATE: It actually works now. And it's fucking sexy.
*** DONE Seriously fucking clean up the message/reply thing
    Holy shit this whole thing is a huge mess. Maybe with
    some moving around, organizing, and renaming it'll look
    a little cleaner, but holy shit no wonder it breaks all
    the fucking time
    Update: I guess it's okay for now...
** DONE Sheeple is horribly broken -- fix it
   At this point, it's probably a better idea to go over all of sheeple again, bit by bit,
   and reimplement things as necessary. Try to clean up the interface and all that.
   Dispatch is completely broken, but it's probably due to reply definition. It might also
   have been caused by all the damn renaming I did all over the place. I really never learn
   my lesson.
   Ah well, there goes the rest of my week.
   UPDATE: Woo, it seems to work now!
** DONE Tests
   All these changes should have a completely new set of unit tests written for them.
   While I'm at it, this could be an opportunity to improve the structure of the tests,
   and improve overall test coverage. They're broken right now, anyways. Ah well :\
   Do not tag and release 2.0 until all tests are written, and pass.
   Update: screw it. I'll write message-related tests later.
*** DONE Sheeple.lisp
*** DONE properties.lisp
*** DONE protos.lisp
*** DONE builtins.lisp
** DONE Fix bugs
   The tests should oust a bunch of bugs. Fix them.
** DONE Rewrite documentation
** DONE Rewrite examples
** DONE Figure out init-sheep
   Where should it go? What should it do?
   It would be nice if it was called -after- properties were
   added when using defclone/defproto. Or maybe the standard
   reply should add property-definitions handed to spawn-sheep
   by defclone/defproto?
   Init-sheep is fine. It should be noted that init-sheep runs after parents
   are added, but before any direct properties are set.
* DONE 1.1
** DONE Rewrite sheeple using CLOS
** DONE Expose enough of a MOP for psheep to be able to do its thing.
** DONE No-arg buzzwords don't work. Fix it.
** DONE Document new MOP features
* DONE 1.0.1
** DONE Allow individual message documentation
** DONE Add CLONE/CLONE*/DEFSHEEP :documentation option
** DONE Write a small sample application
   This will really help me iron out any last details in the API that are important enough to have
   there before 1.0 ships. Plus, it's silly to release shit without even trying it...
   I thought it would be a good idea to convert yashmup, but the current approach of simply renaming
   everything doesn't work, because of the behavior of prototypes, and the setup I had for classes
   (which was pretty awful).
   What I should do instead is start a different project, based on yashmup, but coded in sheeple
   from the bottom up.
   UPDATE: There's been lots of progress since I started working on UID. Tagging this as done (for now)
** DONE Document code
    Note: I can use stuff from the user's guide for this, but it's important.
    UPDATE: it's documented enough (for now).
** DONE Fix the fucking :around message dispatch bullshit.
   THERE. DONE. FUCK.
** DONE Dispatching messages with things like strings or numbers creates a new wolf every time.
   This is pretty terrible. I should at least fix stuff so that fleeced wolves are created only
   when necessary.
   Note: Fleeced wolves only need to exist if there are messages defined on them. Thus, if a message
   is dispatched, it first checks if there is a wolf created for that built-in type. If not, it
   can just find its built-in 'parent'.
   This is such a horrible source of memory leakage.
* DONE 1.0
** DONE Complete documentation
*** DONE Write proper user guide
*** DONE Update guide
** DONE Fix any bugs unit tests come up with
*** DONE Oops -- CLONE should check that defining an accessor first, then passing it NIL is also an error
*** DONE Undefmessage really isn't doing what it's supposed to.
    All tests pass, too!
** DONE Finalize API
   No (significant) changes allowed to API until 2.0, after this release.
*** DONE Do I want to make CLONE work more like defclass*?
    That might be good. It would not be incompatible with older versions of Sheeple, either.
*** DONE Deprecate :manipulator?
    I should deprecate :manipulator in favor of :accessor, since with-accessors will work on both
    CLOS and Sheeple. :accessor is much nicer... I'll remain compatible for now.
*** DONE Go through src/packages.lisp and figure out how much I actually need right now.
*** DONE Should I shut off access to stuff like undefbuzzword/undefmessage?
    Undefbuzzword definitely gone, undefmessage staying for now.
*** DONE (De-)(Re-)implement property objects, allow them to be lockable
    Actually, I think I should get rid of property-objects and make it just so an entire sheep can
    be locked at once.
    UPDATE: All set. Sheeple are now locked as a whole.
*** DONE Forgot MITOSIS >_>
    lol, no I didn't -- but it needed to be fixed anyway
*** DONE Is a :copy-on-clone option for individual properties better than :cloneform for most purposes?
    No.
*** DONE Need a way to list all messages that a sheep can participate in
    LOLOLOLO I ALREADY DID THIS XD XD XD
*** DONE Finalize everything when all else is done.
** DONE Fucking get rid of all these optimization declarations.
   One of these days I'll learn to heed my own fucking advice
* DONE 0.9
** DONE More optimization
   The goal here is to have manipulator dispatch be at a maximum 2x slower than property-value. If I
   can get it as fast as direct property-access, even better, but this shit can go so much faster
   without too much magic.
   Update: currently down to just under 10x slower for single dispatch vs direct property access
   Update: make that 5x slower. ;)
   Update: Sped up (setf property-value) a bit. I'm going to have to make a decision about what
   needs to be faster here -- perhaps I'll find out once I write some apps.
   Update: Caching property-owners was silly, and became incredibly expensive
   Update: Will stop optimizing after manipulators are optimized to an acceptable speed.
   Update: 5x really isn't that bad. I'm going to keep it for now.
** DONE Convert CHANGELOG to .org
** DONE Redefining buzzwords
   It would be really nice if buzzword-redefinition followed the same rules as CLOS
   Update: Good enough for now. It warns about shit.
* DONE 0.8
** DONE Optimize the shit out of message dispatch
   It's pretty fast right now, but nothing compared to PCL.
   I should read through the Slate paper again and see if I can implement any of their
   suggested optimizations.
   Additionally, I found a paper that talks about how PCL's caching works. I think I can
   implement something similar in sheeple, which would then make message dispatch absurdly fast.
   One word: MEMOIZATION. Do it.
   Memoization done, but profiling shows that there's other stuff in the way (such as the
   numerous calls to remove-if-not -during- dispatch time. Shit.
   As far as this remove-if-not, etc stuff goes -- I think I can figure out some fancy
   message-list caching system. The problem is that make-message-lambda might get confused, and
   I want to avoid changing stuff outside of message-dispatch.lisp as much as possible.
   There will be a time in the future when heavy-optimization and code-uglying will be appropriate.
   But for now, while the system is still being designed, it's best to keep things clean and
   flexible (and slow...).
   UPDATE: New caching system has made shit run hella-fast. According to sb-sprof, the next step
   would be to have a nicer hashing scheme, since using a list and using equal to fetch stuff from
   a hash table isn't really very speedy. For now, though, this will do! :) (haven't really tested
   this too much, though. Hm.)
** DONE Fix lambda-list keyword things
* DONE 0.7
** DONE Make initialize-instance a buzzword so :after messages can be defined
   both initialize-instance and reinitialize-instance are regular buzzwords now.
** DONE Have buzzwords accept &keywords in lambda lists, and maintain congruence as per CLOS
   This seemed to be working, but I have to put &allow-other-keys in all methods in order for it
   to work, which is sub-optimal. This can be fixed, and I should do it by 0.8
   UPDATE: Fix'd in make-message-lambda :)
* DONE 0.6
** DONE Write a replace-sheep function
  it should swap a sheep's properties/contents with a new 'definition',
  while maintaining identity.
** DONE Wrap replace-sheep with a DEFSHEEP macro.
** DONE Optimize the shit out of property-access
  Done for now -- it's only slightly slower than PCL right now
** DONE Work out the whole conditions thing, and what they print out.
   Put them all in conditions.lisp?
* DONE 0.5
** DONE Get all pre-0.6 done by 0.5
